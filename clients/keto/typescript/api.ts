/* tslint:disable */
/* eslint-disable */
/**
 * ORY Keto
 * Ory Keto is a cloud native access control server providing best-practice patterns (RBAC, ABAC, ACL, AWS IAM Policies, Kubernetes Roles, ...) via REST APIs.
 *
 * The version of the OpenAPI document: v0.7.0-alpha.0
 * Contact: hi@ory.sh
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ExpandTree
 */
export interface ExpandTree {
    /**
     * 
     * @type {Array<ExpandTree>}
     * @memberof ExpandTree
     */
    children?: Array<ExpandTree>;
    /**
     * 
     * @type {string}
     * @memberof ExpandTree
     */
    subject_id?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof ExpandTree
     */
    subject_set?: SubjectSet;
    /**
     * 
     * @type {string}
     * @memberof ExpandTree
     */
    type: ExpandTreeTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ExpandTreeTypeEnum {
    Union = 'union',
    Exclusion = 'exclusion',
    Intersection = 'intersection',
    Leaf = 'leaf'
}

/**
 * The content of the allowed field is mirrored in the HTTP status code.
 * @export
 * @interface GetCheckResponse
 */
export interface GetCheckResponse {
    /**
     * whether the relation tuple is allowed
     * @type {boolean}
     * @memberof GetCheckResponse
     */
    allowed: boolean;
}
/**
 * 
 * @export
 * @interface GetRelationTuplesResponse
 */
export interface GetRelationTuplesResponse {
    /**
     * The opaque token to provide in a subsequent request to get the next page. It is the empty string iff this is the last page.
     * @type {string}
     * @memberof GetRelationTuplesResponse
     */
    next_page_token?: string;
    /**
     * 
     * @type {Array<InternalRelationTuple>}
     * @memberof GetRelationTuplesResponse
     */
    relation_tuples?: Array<InternalRelationTuple>;
}
/**
 * 
 * @export
 * @interface HealthNotReadyStatus
 */
export interface HealthNotReadyStatus {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof HealthNotReadyStatus
     */
    errors?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface HealthStatus
 */
export interface HealthStatus {
    /**
     * Status always contains \"ok\".
     * @type {string}
     * @memberof HealthStatus
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse400
     */
    code?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof InlineResponse400
     */
    details?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    request?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InternalRelationTuple
 */
export interface InternalRelationTuple {
    /**
     * Namespace of the Relation Tuple
     * @type {string}
     * @memberof InternalRelationTuple
     */
    namespace: string;
    /**
     * Object of the Relation Tuple
     * @type {string}
     * @memberof InternalRelationTuple
     */
    object: string;
    /**
     * Relation of the Relation Tuple
     * @type {string}
     * @memberof InternalRelationTuple
     */
    relation: string;
    /**
     * SubjectID of the Relation Tuple  Either SubjectSet or SubjectID are required.
     * @type {string}
     * @memberof InternalRelationTuple
     */
    subject_id?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof InternalRelationTuple
     */
    subject_set?: SubjectSet;
}
/**
 * 
 * @export
 * @interface PatchDelta
 */
export interface PatchDelta {
    /**
     * 
     * @type {string}
     * @memberof PatchDelta
     */
    action?: PatchDeltaActionEnum;
    /**
     * 
     * @type {InternalRelationTuple}
     * @memberof PatchDelta
     */
    relation_tuple?: InternalRelationTuple;
}

/**
    * @export
    * @enum {string}
    */
export enum PatchDeltaActionEnum {
    Insert = 'insert',
    Delete = 'delete'
}

/**
 * 
 * @export
 * @interface RelationQuery
 */
export interface RelationQuery {
    /**
     * Namespace of the Relation Tuple
     * @type {string}
     * @memberof RelationQuery
     */
    namespace: string;
    /**
     * Object of the Relation Tuple
     * @type {string}
     * @memberof RelationQuery
     */
    object?: string;
    /**
     * Relation of the Relation Tuple
     * @type {string}
     * @memberof RelationQuery
     */
    relation?: string;
    /**
     * SubjectID of the Relation Tuple  Either SubjectSet or SubjectID can be provided.
     * @type {string}
     * @memberof RelationQuery
     */
    subject_id?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof RelationQuery
     */
    subject_set?: SubjectSet;
}
/**
 * 
 * @export
 * @interface SubjectSet
 */
export interface SubjectSet {
    /**
     * Namespace of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    namespace: string;
    /**
     * Object of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    object: string;
    /**
     * Relation of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    relation: string;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * Version is the service\'s version.
     * @type {string}
     * @memberof Version
     */
    version?: string;
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceAlive: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/alive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceReady: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isInstanceAlive(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isInstanceAlive(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isInstanceReady(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isInstanceReady(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceAlive(options?: any): AxiosPromise<HealthStatus> {
            return localVarFp.isInstanceAlive(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceReady(options?: any): AxiosPromise<HealthStatus> {
            return localVarFp.isInstanceReady(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - interface
 * @export
 * @interface HealthApi
 */
export interface HealthApiInterface {
    /**
     * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check alive status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    isInstanceAlive(options?: any): AxiosPromise<HealthStatus>;

    /**
     * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check readiness status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    isInstanceReady(options?: any): AxiosPromise<HealthStatus>;

}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI implements HealthApiInterface {
    /**
     * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check alive status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public isInstanceAlive(options?: any) {
        return HealthApiFp(this.configuration).isInstanceAlive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check readiness status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public isInstanceReady(options?: any) {
        return HealthApiFp(this.configuration).isInstanceReady(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReadApi - axios parameter creator
 * @export
 */
export const ReadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {string} namespace Namespace of the Relation Tuple
         * @param {string} object Object of the Relation Tuple
         * @param {string} relation Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheck: async (namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getCheck', 'namespace', namespace)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('getCheck', 'object', object)
            // verify required parameter 'relation' is not null or undefined
            assertParamExists('getCheck', 'relation', relation)
            const localVarPath = `/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to expand a relation tuple.
         * @summary Expand a Relation Tuple
         * @param {string} namespace Namespace of the Subject Set
         * @param {string} object Object of the Subject Set
         * @param {string} relation Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpand: async (namespace: string, object: string, relation: string, maxDepth?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getExpand', 'namespace', namespace)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('getExpand', 'object', object)
            // verify required parameter 'relation' is not null or undefined
            assertParamExists('getExpand', 'relation', relation)
            const localVarPath = `/expand`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all relation tuples that match the query. Only the namespace field is required.
         * @summary Query relation tuples
         * @param {string} namespace Namespace of the Relation Tuple
         * @param {string} object Object of the Relation Tuple
         * @param {string} relation Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {string} [pageToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationTuples: async (namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, pageToken?: string, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getRelationTuples', 'namespace', namespace)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('getRelationTuples', 'object', object)
            // verify required parameter 'relation' is not null or undefined
            assertParamExists('getRelationTuples', 'relation', relation)
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {RelationQuery} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheck: async (payload?: RelationQuery, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReadApi - functional programming interface
 * @export
 */
export const ReadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReadApiAxiosParamCreator(configuration)
    return {
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {string} namespace Namespace of the Relation Tuple
         * @param {string} object Object of the Relation Tuple
         * @param {string} relation Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheck(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheck(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to expand a relation tuple.
         * @summary Expand a Relation Tuple
         * @param {string} namespace Namespace of the Subject Set
         * @param {string} object Object of the Subject Set
         * @param {string} relation Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpandTree>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpand(namespace, object, relation, maxDepth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all relation tuples that match the query. Only the namespace field is required.
         * @summary Query relation tuples
         * @param {string} namespace Namespace of the Relation Tuple
         * @param {string} object Object of the Relation Tuple
         * @param {string} relation Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {string} [pageToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationTuples(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, pageToken?: string, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRelationTuplesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationTuples(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, pageToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {RelationQuery} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCheck(payload?: RelationQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCheck(payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReadApi - factory interface
 * @export
 */
export const ReadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReadApiFp(configuration)
    return {
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {string} namespace Namespace of the Relation Tuple
         * @param {string} object Object of the Relation Tuple
         * @param {string} relation Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheck(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any): AxiosPromise<GetCheckResponse> {
            return localVarFp.getCheck(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to expand a relation tuple.
         * @summary Expand a Relation Tuple
         * @param {string} namespace Namespace of the Subject Set
         * @param {string} object Object of the Subject Set
         * @param {string} relation Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: any): AxiosPromise<ExpandTree> {
            return localVarFp.getExpand(namespace, object, relation, maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all relation tuples that match the query. Only the namespace field is required.
         * @summary Query relation tuples
         * @param {string} namespace Namespace of the Relation Tuple
         * @param {string} object Object of the Relation Tuple
         * @param {string} relation Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {string} [pageToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationTuples(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, pageToken?: string, pageSize?: number, options?: any): AxiosPromise<GetRelationTuplesResponse> {
            return localVarFp.getRelationTuples(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, pageToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {RelationQuery} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheck(payload?: RelationQuery, options?: any): AxiosPromise<GetCheckResponse> {
            return localVarFp.postCheck(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReadApi - interface
 * @export
 * @interface ReadApi
 */
export interface ReadApiInterface {
    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {string} namespace Namespace of the Relation Tuple
     * @param {string} object Object of the Relation Tuple
     * @param {string} relation Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    getCheck(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any): AxiosPromise<GetCheckResponse>;

    /**
     * Use this endpoint to expand a relation tuple.
     * @summary Expand a Relation Tuple
     * @param {string} namespace Namespace of the Subject Set
     * @param {string} object Object of the Subject Set
     * @param {string} relation Relation of the Subject Set
     * @param {number} [maxDepth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: any): AxiosPromise<ExpandTree>;

    /**
     * Get all relation tuples that match the query. Only the namespace field is required.
     * @summary Query relation tuples
     * @param {string} namespace Namespace of the Relation Tuple
     * @param {string} object Object of the Relation Tuple
     * @param {string} relation Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {string} [pageToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    getRelationTuples(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, pageToken?: string, pageSize?: number, options?: any): AxiosPromise<GetRelationTuplesResponse>;

    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {RelationQuery} [payload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    postCheck(payload?: RelationQuery, options?: any): AxiosPromise<GetCheckResponse>;

}

/**
 * ReadApi - object-oriented interface
 * @export
 * @class ReadApi
 * @extends {BaseAPI}
 */
export class ReadApi extends BaseAPI implements ReadApiInterface {
    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {string} namespace Namespace of the Relation Tuple
     * @param {string} object Object of the Relation Tuple
     * @param {string} relation Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public getCheck(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any) {
        return ReadApiFp(this.configuration).getCheck(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to expand a relation tuple.
     * @summary Expand a Relation Tuple
     * @param {string} namespace Namespace of the Subject Set
     * @param {string} object Object of the Subject Set
     * @param {string} relation Relation of the Subject Set
     * @param {number} [maxDepth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: any) {
        return ReadApiFp(this.configuration).getExpand(namespace, object, relation, maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all relation tuples that match the query. Only the namespace field is required.
     * @summary Query relation tuples
     * @param {string} namespace Namespace of the Relation Tuple
     * @param {string} object Object of the Relation Tuple
     * @param {string} relation Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {string} [pageToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public getRelationTuples(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, pageToken?: string, pageSize?: number, options?: any) {
        return ReadApiFp(this.configuration).getRelationTuples(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, pageToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {RelationQuery} [payload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public postCheck(payload?: RelationQuery, options?: any) {
        return ReadApiFp(this.configuration).postCheck(payload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionApiFp(configuration)
    return {
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<Version> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - interface
 * @export
 * @interface VersionApi
 */
export interface VersionApiInterface {
    /**
     * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Get service version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApiInterface
     */
    getVersion(options?: any): AxiosPromise<Version>;

}

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI implements VersionApiInterface {
    /**
     * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Get service version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getVersion(options?: any) {
        return VersionApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WriteApi - axios parameter creator
 * @export
 */
export const WriteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a relation tuple.
         * @summary Create a Relation Tuple
         * @param {RelationQuery} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelationTuple: async (payload?: RelationQuery, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete a relation tuple.
         * @summary Delete a Relation Tuple
         * @param {string} namespace Namespace of the Relation Tuple
         * @param {string} object Object of the Relation Tuple
         * @param {string} relation Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationTuple: async (namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteRelationTuple', 'namespace', namespace)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('deleteRelationTuple', 'object', object)
            // verify required parameter 'relation' is not null or undefined
            assertParamExists('deleteRelationTuple', 'relation', relation)
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to patch one or more relation tuples.
         * @summary Patch Multiple Relation Tuples
         * @param {Array<PatchDelta>} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelationTuples: async (payload?: Array<PatchDelta>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WriteApi - functional programming interface
 * @export
 */
export const WriteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WriteApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a relation tuple.
         * @summary Create a Relation Tuple
         * @param {RelationQuery} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRelationTuple(payload?: RelationQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelationQuery>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRelationTuple(payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete a relation tuple.
         * @summary Delete a Relation Tuple
         * @param {string} namespace Namespace of the Relation Tuple
         * @param {string} object Object of the Relation Tuple
         * @param {string} relation Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelationTuple(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelationTuple(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to patch one or more relation tuples.
         * @summary Patch Multiple Relation Tuples
         * @param {Array<PatchDelta>} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRelationTuples(payload?: Array<PatchDelta>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRelationTuples(payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WriteApi - factory interface
 * @export
 */
export const WriteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WriteApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a relation tuple.
         * @summary Create a Relation Tuple
         * @param {RelationQuery} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelationTuple(payload?: RelationQuery, options?: any): AxiosPromise<RelationQuery> {
            return localVarFp.createRelationTuple(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete a relation tuple.
         * @summary Delete a Relation Tuple
         * @param {string} namespace Namespace of the Relation Tuple
         * @param {string} object Object of the Relation Tuple
         * @param {string} relation Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationTuple(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRelationTuple(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to patch one or more relation tuples.
         * @summary Patch Multiple Relation Tuples
         * @param {Array<PatchDelta>} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelationTuples(payload?: Array<PatchDelta>, options?: any): AxiosPromise<void> {
            return localVarFp.patchRelationTuples(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WriteApi - interface
 * @export
 * @interface WriteApi
 */
export interface WriteApiInterface {
    /**
     * Use this endpoint to create a relation tuple.
     * @summary Create a Relation Tuple
     * @param {RelationQuery} [payload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApiInterface
     */
    createRelationTuple(payload?: RelationQuery, options?: any): AxiosPromise<RelationQuery>;

    /**
     * Use this endpoint to delete a relation tuple.
     * @summary Delete a Relation Tuple
     * @param {string} namespace Namespace of the Relation Tuple
     * @param {string} object Object of the Relation Tuple
     * @param {string} relation Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApiInterface
     */
    deleteRelationTuple(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any): AxiosPromise<void>;

    /**
     * Use this endpoint to patch one or more relation tuples.
     * @summary Patch Multiple Relation Tuples
     * @param {Array<PatchDelta>} [payload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApiInterface
     */
    patchRelationTuples(payload?: Array<PatchDelta>, options?: any): AxiosPromise<void>;

}

/**
 * WriteApi - object-oriented interface
 * @export
 * @class WriteApi
 * @extends {BaseAPI}
 */
export class WriteApi extends BaseAPI implements WriteApiInterface {
    /**
     * Use this endpoint to create a relation tuple.
     * @summary Create a Relation Tuple
     * @param {RelationQuery} [payload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public createRelationTuple(payload?: RelationQuery, options?: any) {
        return WriteApiFp(this.configuration).createRelationTuple(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete a relation tuple.
     * @summary Delete a Relation Tuple
     * @param {string} namespace Namespace of the Relation Tuple
     * @param {string} object Object of the Relation Tuple
     * @param {string} relation Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public deleteRelationTuple(namespace: string, object: string, relation: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any) {
        return WriteApiFp(this.configuration).deleteRelationTuple(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to patch one or more relation tuples.
     * @summary Patch Multiple Relation Tuples
     * @param {Array<PatchDelta>} [payload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public patchRelationTuples(payload?: Array<PatchDelta>, options?: any) {
        return WriteApiFp(this.configuration).patchRelationTuples(payload, options).then((request) => request(this.axios, this.basePath));
    }
}


